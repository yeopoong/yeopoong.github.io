---
layout: post
published: false
title: "Array"
categories: interview
tags: interview array
---

## Array

순서가 중요한 경우는 스택으로 체크한다.
스택에 어떤값을 넣을지는 결과값에 따라서 달라진다.
Prefix Sum

[Easy]
- [1. Two Sum](https://leetcode.com/problems/two-sum/)
- [268. Missing Number](https://leetcode.com/problems/missing-number/)
- [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)
- [704. Binary Search](https://leetcode.com/problems/binary-search/)

[Medium]
- [11. Container With Most Water](https://leetcode.com/problems/container-with-most-water/)
- [53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)
- [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)
- [1151. Minimum Swaps to Group All 1's Together](https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together/)

[Hard]
- [42. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water)

## Subarray
> A subarray is a contiguous non-empty sequence of elements within an array.

- [1588. Sum of All Odd Length Subarrays](https://leetcode.com/problems/sum-of-all-odd-length-subarrays/)
- [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)
- [325. Maximum Size Subarray Sum Equals k](https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/)

[Hard]
- [862. Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/)

## Subsequence

- [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)

## Consecutive

- [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/)
```java
class Solution {
    
    // 최대 k개의 0을 뒤집을 수 있는 경우, 배열에서 최대 연속 1의 수
    // T: O(n)
    public int longestOnes(int[] nums, int k) {
        int left = 0, right;
        
        for (right = 0; right < nums.length; right++) {
            // 0이 포함되면 K를 감소한다.
            if (nums[right] == 0) {
                k--;
            }
            // 허용된 수보다 많은 0이 존재하면
            if (k < 0 && nums[left++] == 0) {
                k++;
            }
        }     
        
        return right - left;
    }
}
```