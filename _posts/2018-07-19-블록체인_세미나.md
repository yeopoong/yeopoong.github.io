---
layout: post
title: "개발자가 바라보는 블록체인"
subtitle: "Blockchain"
categories: lecture
tags: blockchain
---

# 목차

1. 블록체인
    - 블록체인 개요
    - 블록체인 핵심기술
2. 비트코인
    - 비트코인 코어
    - 비트코인 블럭
3. 이더리움 
    - 이더리움 개요
    - 이더리움 Private 네트워크 구축(Go Ethereum: Geth)
    - 솔리디티(Solidity) 소개 및 동작 방식 
    - Remix 개발환경 
    - 클라우드 세일(Crowd Sale) 데모
4. 기타등등
    - ICO(Initial Coin Offering)
    - 블록체인 백서(Whitepaper)

# 블록체인

## 블록체인 혁명

> 인터넷의 두 번째 세대를 표방하며 돈과 경제, 정부와 사회를 변화시킬 잠재력을 가진 **신뢰 구축 기술**
>
><small>-- *[Don Tapscott - TedSummit, How the blockchain is changing money and business](https://www.ted.com/talks/don_tapscott_how_the_blockchain_is_changing_money_and_business?language=ko#t-1117717)*</small>

* The Internet of Information
  - 복사본 전송이 문제 되지 않음
* An Internet of Value
  - 이중지불 문제
* The Middleman
  - 신뢰보증 -> 은행, 정부, 소셜 미디어
* 문제점 
  - 집중화
  - 지연
  - 수수료
  - **불평등**
* An Internet of Value
  - 비트코인: 금융기관 시스템에 대한 불신으로부터 시작
  - 사토시 나카모토
  - 중계자 없이 가치를 전송할 수 있는 전자화폐 프로토콜
  - 분산/암호화 기술을 이용하여 신뢰 확보

## 블록체인이 해결하려고 하는 문제

* 탈중앙화

* 보안 
  - 디지털 화폐
  - 가치의 이동: 이중지불 문제
  - 암호화

## 블록체인 아키텍처

* P2P(Peer to Peer)
  - 노드
  - 피어
  - 메인넷

* 분산원장(Distributed Ledger)
  - 블록(Block)
  - 해시(Hash)
  - 채굴(Mining)
  - https://blockchain.info/ko

* 합의 알고리즘(Consensus Algorithm) 
  - 블록생성 권한 분배
  - 포크 발생시 하나의 체인 선택
  - 비잔틴 장군 문제(Byzantine General Problem)

* 보안

# 비트코인(Bitcoin)

## 비트코인 코어

```
```

### 테스트 네트워크

```
$ bitcoind -regtest -daemon
Bitcoin server starting
```

### 블록생성 

```
$ bitcoin-cli -regtest generate 101
```

### 블록 수 확인 

```
$ bitcoin-cli -regtest getblockcount
```

### 계좌생성

```
$ bitcoin-cli -regtest getnewaddress testuser100 
2N7EHkYKrLbKqDybPY6cFoXXJ3ts4ArAKGb

$ bitcoin-cli -regtest getnewaddress testuser200 
2NCPnDMEeKkHRujxZGiFoxvp9SpSfVnHAAA
```

### 잔고확인 

```
$ bitcoin-cli -regtest getbalance
$ bitcoin-cli -regtest getbalance testuser100
```

### 송금

```
$ bitcoin-cli -regtest sendtoaddress 2N7EHkYKrLbKqDybPY6cFoXXJ3ts4ArAKGb 20 
99337e1bab6d56b694206781750d808e2b6a13695fa7a93c37ecead0394204f9

$ bitcoin-cli -regtest sendtoaddress 2N7EHkYKrLbKqDybPY6cFoXXJ3ts4ArAKGb 30 
ef7646de272a2d694db8c4394e0d7f8d8b4e62ee70f6d382b8dc81526148e0d5

$ bitcoin-cli -regtest sendtoaddress 2NCPnDMEeKkHRujxZGiFoxvp9SpSfVnHAAA 20 
d9ad57bec93fbec8f495d57069ce867d6a53b6f9cc74713ec62a903711319c90

$ bitcoin-cli -regtest sendtoaddress 2NCPnDMEeKkHRujxZGiFoxvp9SpSfVnHAAA 30 
f427bb622954d8049abe0ff9d6a8ed6d9e502c6a771d8a55b09b203dc637f846
```

### 트랜잭션 확인 

```
$ bitcoin-cli -regtest listunspent
$ bitcoin-cli -regtest listunspent 0 0 
```

### 채굴

```sh
$ bitcoin-cli -regtest generate 1 
[
  "096bec61ffe3b47930b04ba042127a6eac77e950d5dfa27521be2eee59aa6c9f"
]
```

### 블록확인

```sh
# 블록 해시 구하기
$ bitcoin-cli -regtest getblockhash 203 
096bec61ffe3b47930b04ba042127a6eac77e950d5dfa27521be2eee59aa6c9f

$ bitcoin-cli -regtest getbalance testuser200 
50.00000000
$ bitcoin-cli -regtest getbalance testuser100 
50.00000000

$ bitcoin-cli -regtest getblock 096bec61ffe3b47930b04ba042127a6eac77e950d5dfa27521be2eee59aa6c9f
{
  "hash": "096bec61ffe3b47930b04ba042127a6eac77e950d5dfa27521be2eee59aa6c9f",
  "confirmations": 1,
  "strippedsize": 979,
  "size": 1015,
  "weight": 3952,
  "height": 203,
  "version": 805306369,
  "versionHex": "30000001",
  "merkleroot": "03b0c895b3893341e2cd9de85c1d7baa546f29432e4ebcb3cfc6a9e23de1c07f",
  "tx": [
    "9dbf340315152e16d3c795ce76f26460dee5e296c9e28a3a91150ab5c0faaa23",
    "ef7646de272a2d694db8c4394e0d7f8d8b4e62ee70f6d382b8dc81526148e0d5",
    "f427bb622954d8049abe0ff9d6a8ed6d9e502c6a771d8a55b09b203dc637f846",
    "d9ad57bec93fbec8f495d57069ce867d6a53b6f9cc74713ec62a903711319c90",
    "99337e1bab6d56b694206781750d808e2b6a13695fa7a93c37ecead0394204f9"
  ],
  "time": 1527486010,
  "mediantime": 1527483148,
  "nonce": 0,
  "bits": "207fffff",
  "difficulty": 4.656542373906925e-10,
  "chainwork": "0000000000000000000000000000000000000000000000000000000000000198",
  "previousblockhash": "50c1f5031be67b2436b45fb6ead467dbf1346783a0b435339bc8143d5dcdfeb9"
}
```

### 머클 루트 해시 

`merkle.py`
```python
import hashlib
 
def merkle(hashList):
    if len(hashList) == 1:
        return hashList[0]
    newHashList = []
    for i in range(0, len(hashList)-1, 2):
        newHashList.append(hash2(hashList[i], hashList[i+1]))
    if len(hashList) % 2 == 1: # odd, hash last item twice
        newHashList.append(hash2(hashList[-1], hashList[-1]))
    return merkle(newHashList)
 
def hash2(a, b):
    a1 = a.decode('hex')
    a11 = a1[::-1]
    # print a11.encode('hex')
    b1 = b.decode('hex')[::-1]
    #print b1.encode('hex')
    concat = a11+b1
    #print concat.encode('hex')
    concat2 = hashlib.sha256(concat).digest()
    print "hash1:" + concat2.encode('hex')
    h = hashlib.sha256(concat2).digest()
    print "hash2:" + h[::-1].encode('hex')
    print ''
    return h[::-1].encode('hex')
 
txHashes = [
"b86f5ef1da8ddbdb29ec269b535810ee61289eeac7bf2b2523b494551f03897c",
"80c6f121c3e9fe0a59177e49874d8c703cbadee0700a782e4002e87d862373c6"
]  	
 
print merkle(txHashes)
```

### 작업증명 검증

`verify.py`
```python
import hashlib
import binascii

# 1. Getting header values from blockexplorer.com
version = "20000000" # 2
hashPrevBlock = "0000000000000000000e26cad41443d1a38e71d36af6a98a7de2576d105bfdb5"
hashMerkleRoot = "f857ee1324aaca62bbced64b93654a419ed015b79507533a9a13abdf469271b2"
time = "5B0CB754"
bits = "17415A49"
nonce = 4064165647 # in decimal notation
nonce = hex(int(0x100000000)+nonce)[-8:]

# 2. Convert them in little-endian hex notation
version = binascii.hexlify(binascii.unhexlify(version)[::-1])
hashPrevBlock = binascii.hexlify(binascii.unhexlify(hashPrevBlock)[::-1])
hashMerkleRoot = binascii.hexlify(binascii.unhexlify(hashMerkleRoot)[::-1])
time = binascii.hexlify(binascii.unhexlify(time)[::-1])
bits = binascii.hexlify(binascii.unhexlify(bits)[::-1])
nonce = binascii.hexlify(binascii.unhexlify(nonce)[::-1])

# 3. Concatenating header values
header = version+hashPrevBlock+hashMerkleRoot+time+bits+nonce

# 4. Taking the double-SHA256 hash value
header = binascii.unhexlify(header)
hash = hashlib.sha256(hashlib.sha256(header).digest()).digest()
hash = binascii.hexlify(hash)

# 5. Converting the hash value in big-endian hex notation
hash = binascii.hexlify(binascii.unhexlify(hash)[::-1])
print  hash
```

Block #524897
```
$ python verify.py
00000000000000000023f491f301e842d6c955fb8a76360262b774e6d275e541
```

# 이더리움(Ethereum)

* EVM
* Solidity
* Smart Contract

## 토큰 vs 코인

## Go Ethereum
> Official Go implementation of the Ethereum protocol

## Install Geth

https://ethereum.github.io/go-ethereum/downloads/

```
$ sudo apt-get install software-properties-common
$ sudo add-apt-repository -y ppa:ethereum/ethereum 
$ sudo add-apt-repository -y ppa:ethereum/ethereum-dev

$ sudo apt-get update
$ sudo apt-get install ethereum
```

설치 정보 확인
```
$ geth version
Geth Version: 1.8.2-stable
Git Commit: b8b9f7f4476a30a0aaf6077daade6ae77f969960
Architecture: amd64
Protocol Versions: [63 62]
Network Id: 1
Go Version: go1.9.4
```

## Private 네트워크 구축 

### Geth 초기화 

```
$ mkdir testnet
$ cd testnet/
$ vi genesis.json
```

```json
{
  "config": {
    "chainId": 33,
    "homesteadBlock": 0,
    "eip155Block": 0,
    "eip158Block": 0
  },
  "nonce": "0x0000000000000033",
  "timestamp": "0x0",
  "parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "gasLimit": "0x8000000",
  "difficulty": "0x100",
  "mixhash": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "coinbase": "0x3333333333333333333333333333333333333333",
  "alloc": {}
}
```

```
$ geth --datadir /home/vagrant/testnet/ init /home/vagrant/testnet/genesis.json
```

### 이더리움 디렉토리 구조

```
$ sudo apt-get install tree
$ tree /home/vagrant/testnet 
.
├── genesis.json
├── geth
│   ├── chaindata
│   │   ├── 000001.log
│   │   ├── CURRENT
│   │   ├── LOCK
│   │   ├── LOG
│   │   └── MANIFEST-000000
│   └── lightchaindata
│       ├── 000001.log
│       ├── CURRENT
│       ├── LOCK
│       ├── LOG
│       └── MANIFEST-000000
└── keystore

4 directories, 11 files
```

### Geth 실행 

### Geth Console 

```
$ geth --identity "PrivateNetwork" --datadir "/home/vagrant/testnet/" --port "30303" --rpc --rpcaddr 0.0.0.0 --rpcport "8123" --rpccorsdomain "*" --nodiscover --networkid 1900 --rpcapi "db,eth,net,web3,miner" console 2>> /home/vagrant/testnet/geth.log
```

### Start & Kill

```
$ nohup geth --networkid 4649 --nodiscover --datadir /home/vagrant/testnet --rpc --rpcaddr "0.0.0.0" --rpcport 8545 --rpccorsdomain "*" --rpcapi "admin,db,eth,debug,miner,net,shh,txpool,personal,web3" --verbosity 6 2>>/home/vagrant/testnet/geth.log & 

$ kill $(ps aux | grep geth | grep rpc | awk '{print $2}')
```

Note! --prcaddr, --rpcport, --rpccorsdomain, --rpcapi 는 보안을 고려해야한다.

### Console 연결

```
$ geth attach http://localhost:8545
Welcome to the Geth JavaScript console!

instance: Geth/v1.8.2-stable-b8b9f7f4/linux-amd64/go1.9.4
 modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0

> 
```

### 계정 생성과 조회 

```
Welcome to the Geth JavaScript console!

instance: Geth/PrivateNetwork/v1.8.2-stable-b8b9f7f4/linux-amd64/go1.9.4
 modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0

> eth
> eth.accounts
[]
> net.peerCount
0

> personal.newAccount("pass0")
"0x7a8f36c21f1b2f89a9f6c810c1289b88e559f85c"
> personal.newAccount("pass1")
"0xbd2cc6e8c322be5a43c862d39984980076930d0d"

> eth.accounts
["0x7a8f36c21f1b2f89a9f6c810c1289b88e559f85c", "0xbd2cc6e8c322be5a43c862d39984980076930d0d"]

> eth.getBalance(eth.accounts[0])
0
> eth.getBalance(eth.accounts[1])
0
> eth.getBalance(eth.coinbase)
0
```

### 채굴

```
> miner.start()
null
> eth.getBalance(eth.coinbase)
115000000000000000000
> web3.fromWei(eth.getBalance(eth.coinbase))
185
> miner.stop()
true
> eth.blockNumber
37
```

### 송금

```
> personal.unlockAccount(eth.accounts[0])
Unlock account 0x7a8f36c21f1b2f89a9f6c810c1289b88e559f85c
Passphrase: 
true

> eth.sendTransaction({from:eth.accounts[0], to:eth.accounts[1], value:web3.toWei(10,"ether")})
"0x8fbfdacc783756decfdd68ecdb4f7f35fdee5fb8b43e23983c7072bf38822ae1"
> eth.sendTransaction({from:eth.accounts[0], to:eth.accounts[1], value:web3.toWei(20,"ether")})
"0x1217431a1fc1d1b1fc1b750fcf84e46f4238044d9d629cca04dbb891c823f97d"
> eth.sendTransaction({from:eth.accounts[0], to:eth.accounts[1], value:web3.toWei(12,"ether")})
"0x1350b63b35a47f5d9f8b553fe08ba82fe6c2709c4505b5e7a063f676bcb95218"

> eth.getTransaction("0x8fbfdacc783756decfdd68ecdb4f7f35fdee5fb8b43e23983c7072bf38822ae1")
{
  blockHash: "0x0000000000000000000000000000000000000000000000000000000000000000",
  blockNumber: null,
  from: "0x7a8f36c21f1b2f89a9f6c810c1289b88e559f85c",
  gas: 90000,
  gasPrice: 18000000000,
  hash: "0x8fbfdacc783756decfdd68ecdb4f7f35fdee5fb8b43e23983c7072bf38822ae1",
  input: "0x",
  nonce: 0,
  r: "0x91626fa3e14ca6407d2928d59059575cb2717ff0baadfb6c397962281c67e198",
  s: "0x68b26e0306a6e8ed34360cf6a650ff9ca151f9aba1139c3705cf05f1a0449e80",
  to: "0xbd2cc6e8c322be5a43c862d39984980076930d0d",
  transactionIndex: 0,
  v: "0x66",
  value: 10000000000000000000
}

# 채굴되지 않은 트랜잭션 리스트
> eth.pendingTransactions
> miner.start()
null
> eth.pendingTransactions
[]
> miner.stop()
true
> eth.pendingTransactions
[]

> eth.blockNumber
43
> eth.getBlock(43)
{
  difficulty: 131328,
  extraData: "0xd783010802846765746887676f312e392e34856c696e7578",
  gasLimit: 128695843,
  gasUsed: 0,
  hash: "0xbfb8727fb4b56163f57fa5ebfd8cc677514a6e1e731e08c67a092ee56c1df2f3",
  logsBloom: "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
  miner: "0x7a8f36c21f1b2f89a9f6c810c1289b88e559f85c",
  mixHash: "0x646c28605eca9abf3283f7a6e1556431652b6fcba4455a33d780c0f553a736af",
  nonce: "0x000510e55c54ad12",
  number: 43,
  parentHash: "0x53d1e0aa4a211f4e76772eb214fe1afc2be0f965fdedcef80137eafe4e051a43",
  receiptsRoot: "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421",
  sha3Uncles: "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347",
  size: 536,
  stateRoot: "0x3a06000c8690c54e0fccb390958b519b7de12cf0d44c593a9919841cb10c9149",
  timestamp: 1527579249,
  totalDifficulty: 5673536,
  transactions: [],
  transactionsRoot: "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421",
  uncles: []
}
```

### Peer 연결

```
> admin.nodeInfo.enode
"enode://b128200b26a55a5aa2b605905b1dfa9be8426cf6d8f73c1a1c0ea89e4d4771a98feead21cc9830b772c559d42b91ee2455fad4402738571cad61f17c93b787ae@[::]:30303?discport=0"
```

```
> admin.addPeer("enode://b128200b26a55a5aa2b605905b1dfa9be8426cf6d8f73c1a1c0ea89e4d4771a98feead21cc9830b772c559d42b91ee2455fad4402738571cad61f17c93b787ae@192.168.0.202:30303?discport=0")
> net.peerCount
0
> admin.peers
[]
```

## Ethereum Architecture

* EVM(Ethereum Virtual Machine)
* Solidity
* Remix

## 솔리디티(Solidity)
> Solidity is a contract-oriented, high-level language for implementing smart contracts. 

## Remix 개발환경

`http://remix.ethereum.org`

![](/asset/img/remix.jpg)

## Remix 환경설정 

* Environment : Web3 Provider
  - Web3 Provider Endpoint -> http://192.168.0.207:8545

* Account 에서 계정 연결을 확인

* Compile
  - Check "Auto compile"

* Settings
  - Solidity version: 0.4.18+commit.9cf6e910

## 기본예제

```
pragma solidity ^0.4.18;

contract SimpleStorage {
    uint storedData;

    function set(uint x) public {
        storedData = x;
    }

    function get() public constant returns (uint) {
        return storedData;
    }
}
```

## Deploy

* Account 선택
* Value: 1 ether
* Deploy 
  + geth 콘솔에서 personal.unlockAccount(eth.accounts[0]) 수행

## 동작 방식

컴파일, 가상환경, 가스, 수수료, 채굴

## Web3  
> web3.js - Ethereum JavaScript API

* https://www.mobilefish.com/download/ethereum/web3api.html
* https://www.mobilefish.com/download/ethereum/DemoDapp.html

### Express 설치 

```
$ sudo npm install express-generator -g
/usr/local/bin/express -> /usr/local/lib/node_modules/express-generator/bin/express-cli.js
/usr/local/lib
└─┬ express-generator@4.16.0 
  ├── commander@2.13.0 
  ├── ejs@2.5.7 
  ├─┬ minimatch@3.0.4 
  │ └─┬ brace-expansion@1.1.11 
  │   ├── balanced-match@1.0.0 
  │   └── concat-map@0.0.1 
  ├─┬ mkdirp@0.5.1 
  │ └── minimist@0.0.8 
  └── sorted-object@2.0.1 

$ sudo ln -s /usr/bin/nodejs /usr/bin/node
$ express -h
```

### Express 페이지 생성 

```
$ express --view=pug web3
$ cd web3 && sudo npm install
$ DEBUG=web3 npm start
```

사이트 접속: http://192.168.0.207:3000/

* web3 demo
  - /home/vagrant/web3/public  
    + js, monitor.html 업로드
  - http://192.168.0.207:3000/monitor.html

## Monitor 

`monitor.html`
```html
<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>block view</title>
<script type="text/javascript" src="./js/bignumber.min.js"></script>
<script type="text/javascript" src="./js/crypto-js.js"></script>
<script type="text/javascript" src="./js/utf8.js"></script>
<script type="text/javascript" src="./js/web3-light.js"></script>
<script>
var web3 = new Web3();
var provider = new web3.providers.HttpProvider("http://192.168.0.207:8545");
web3.setProvider(provider);
web3.eth.defaultAccount = web3.eth.accounts[0];
var stop = false;


function startMonitor() {
	stop = false;
	
	var startBlockNo = web3.eth.blockNumber - 20;
	var table = document.getElementById('list');
	var i = startBlockNo;
	for (; i < web3.eth.blockNumber; i++) {
		var result = web3.eth.getBlock(i);
		insertBlockRow(result, table, i);
	}
	setTimeout(function() {
	  watchBlock(table, i);
	}, 10000);
}

function watchBlock(table, blockNumber) {
	if (stop) {
		return;
	}
	if (blockNumber == web3.eth.blockNumber) {
		setTimeout(function() {
		  watchBlock(table, blockNumber);
		}, 10000);
	  return;
	}
	var result = web3.eth.getBlock(blockNumber);
	insertBlockRow(result, table, blockNumber);
	setTimeout(function() {
	watchBlock(table, ++blockNumber);
	}, 10000);
}


function insertBlockRow(result, table) {
	var row = table.insertRow();
	var td = row.insertCell(0);
	td.innerHTML = result.number;
	var td = row.insertCell(1);
	td.innerHTML = new Date(parseInt(result.timestamp, 16) * 1000).toString();
	var td = row.insertCell(2);
	td.innerHTML = result.hash;
	var td = row.insertCell(3);
	td.innerHTML = result.nonce;
	var td = row.insertCell(4);
	if (result.transactions.length > 0) {
	insertTranRow(result.transactions, td);
	}
}


function insertTranRow(transactions, td) {
	var allData = "";
	for (var i = 0; i < transactions.length; i++) {
		var data = web3.eth.getTransaction(transactions[i]);
		allData += JSON.stringify(data);
	}
	td.innerHTML = "<input type='text' value='" + allData + "' /></td>";
}

function stopWatch() {
	stop = true;
}
</script>
</head>
<body>
	<br />
	<input type="button" value="start" onclick="startMonitor();" />
	<input type="button" value="stop" onclick="stopWatch();" />
	<table id="list" border="1">
		<tr>
			<th>Block<br />Number</th>
			<th>TimeStamp</th>
			<th>BlockHash</th>
			<th>Nonce</th>
			<th>Transaction</th>
		</tr>
	</table>
</body>
</html>
```

## 투표 예제

`VoteContract.sol`
```sol
pragma solidity ^0.4.18;

contract VoteContract {

    //하나의 계정 한번만 투표
    mapping(address => bool) voters;

    //후보자의 득표수 저장
    mapping(string => uint) candidates;

    //후보자 리스트
    mapping(uint => string) candidateList;

    //전체 후보자 수
    uint8 numberOfCandidates;
    address contractOwner;

    //생성자 - msg.sender가 contractOwner
    function VoteContract() public {
        contractOwner = msg.sender; 
    }

    //후보자 추가
    function addCandidates(string _cand) public view returns(uint256) {
        bool add = true;
        for (uint8 i = 0; i < numberOfCandidates; i++) {
        }
    }

    //투표
    function vote(string _cand) public view {
        if (voters[msg.sender]) {

        } else {

        }
    }

    //투표 확인
    function alreadyVote() public returns(bool) {
        if (voters[msg.sender]) {
            return true;
        } else {
            return false;
        }
    }

    //후보자수 리턴
    function getNumOfCandidate() public {
        return numberOfCandidates;
    }

    //후보자 이름
    function getCandidateString(uint8 number) public returns() {
        return candidateList[number] 
    }

    //후보 득표수 리턴
    function getScore(string cand) public returns(uint) {
        return candidates[cand];
    }

    //컨트랙트 삭제
    function killContract() public {
        if (contractOwner == msg.sender) {
            selfdestruct(contractOwner);
        }
    }
}
```

```
> personal.unlockAccount(eth.accounts[0])
> miner.start()
```

### ABI(Application Binary Interface) 

```js
var vc = web3.eth.contract(
  ABI
).at("contract address");
```

`vote.html`
```html
<!Doctype html>
<html>
<head>
<meta charset="UTF-8">

<script type="text/javascript" src="./javascripts/web3.min.js"></script>
<script type="text/javascript">
   
    var Web3 = require('web3');
    var web3 = new Web3();
    web3.setProvider(new web3.providers.HttpProvider("http://192.168.0.207:8545"));
	var vc = web3.eth.contract([
		{
			"constant": false,
			"inputs": [
				{
					"name": "cand",
					"type": "string"
				}
			],
			"name": "addCandidate",
			"outputs": [],
			"payable": false,
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"constant": false,
			"inputs": [],
			"name": "killContract",
			"outputs": [],
			"payable": false,
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [],
			"payable": false,
			"stateMutability": "nonpayable",
			"type": "constructor"
		},
		{
			"constant": false,
			"inputs": [
				{
					"name": "cand",
					"type": "string"
				}
			],
			"name": "vote",
			"outputs": [],
			"payable": false,
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"constant": true,
			"inputs": [],
			"name": "alreadyVoted",
			"outputs": [
				{
					"name": "",
					"type": "bool"
				}
			],
			"payable": false,
			"stateMutability": "view",
			"type": "function"
		},
		{
			"constant": true,
			"inputs": [
				{
					"name": "number",
					"type": "uint8"
				}
			],
			"name": "getCandidateString",
			"outputs": [
				{
					"name": "",
					"type": "string"
				}
			],
			"payable": false,
			"stateMutability": "view",
			"type": "function"
		},
		{
			"constant": true,
			"inputs": [],
			"name": "getNumOfCandidates",
			"outputs": [
				{
					"name": "",
					"type": "uint8"
				}
			],
			"payable": false,
			"stateMutability": "view",
			"type": "function"
		},
		{
			"constant": true,
			"inputs": [
				{
					"name": "cand",
					"type": "string"
				}
			],
			"name": "getScore",
			"outputs": [
				{
					"name": "",
					"type": "uint256"
				}
			],
			"payable": false,
			"stateMutability": "view",
			"type": "function"
		}
	]).at("0x128a64bd7749d38675a5ec693d08cb1a044e588a");	

	function showList() {
 		var table=document.getElementById("table1");
		var length = vc.getNumOfCandidates();
		alert(length);            
		for (var i=0;i<length;i++){
			var candidate = vc.getCandidateString(i);
			                   
			var row=table.insertRow();
			var cell1=row.insertCell(0);
			var cell2=row.insertCell(1);
			cell1.innerHTML = candidate;
			cell2.innerHTML = vc.getScore(candidate);
		}
	}

	function vote(){
		var candidate=document.getElementById("candidate").value;
		alert("vote candidate:"+candidate);
		var account=document.getElementById("account").value;
		alert("vote account:"+account);

		web3.eth.defaultAccount = account;
		if(web3.personal.unlockAccount(account,document.getElementById('pass').value)){
			var alreadyVoted=vc.alreadyVoted();
			console.log(alreadyVoted);
			if(alreadyVoted)
				alert("이미 투표하셨습니다.");
			else
				vc.vote(candidate,function(err,result){ if(!err) alert("트랜잭션이 성공적으로 전송되었습니다.|n"+result)});		
		}
	}

	function addCand(){
	var candidate=document.getElementById("candidate").value;
	alert("addCand candidate:"+ candidate);
	var account=document.getElementById("account").value;
    alert("addCand candidate:"+ account);
	
	if(web3.personal.unlockAccount(account,document.getElementById('pass').value)){
		vc.addCandidate(candidate,{from:account,gas:2000000},function(err,result){ if(!err) alert("트랜잭션이 성공적으로 전송되었습니다.|n"+result)});	
	       
	  }
	}

	// 사용자의 계좌들을 select로 만듭니다.
	function makeSelect() { 
		//계좌 선택 구현
		var list = web3.eth.accounts;
		var select = document.getElementById('account');

		for(var i = 0; i < list.length; i++) {
			var opt = document.createElement('option');
			opt.value = list[i];
			opt.innerHTML = list[i];
			select.appendChild(opt);
		}
	}
</script>
<style>
table {    border-collapse: collapse;    border: 4px solid #bbb;	width: 50%;}
tr:nth-child(even){background-color: #ccc}
input, select {
    padding: 6px 10px;
    margin: 4px 0;
    display: inline-block;
    border: 1px solid #ccc;
    border-radius: 3px;
    box-sizing: border-box;}
button:hover {  background-color: gold;}
</style>
</head>
<body>
    <h1>블록체인 투표</h1>
	<div>
	계정: 
	<select name="account" id="account">
	<!--
    <option value="0x57d40ea05687ceedc7353edd2346a0fefacb5f88">account[1]</option>
    <option value="0xbe09b03f61ab49b543b63004ea1c6669e259d051">account[2]</option>
    <option value="0x8ff9c21bdb50a9dc96dff8e0237e92723bfd26c0">account[3]</option>
	-->
   </select>
	패스워드: <input type="password" id="pass" placeholder="암호를 입력하세요">	</div><br>
	<div> <input type="text" id="candidate" value="0000">
	<button onClick="vote()">투표하기</button> 
	<button onClick="addCand()">후보 추가하기</button> </div>
    
	<fieldset style="width:300px">
    <legend>투표 결과</legend>
  
		<table border=1 id="table1" />
		<script>
		makeSelect();
		showList();
		</script>
	</fieldset>

</body>
</html>
```

# 클라우드 세일

```sol
pragma solidity ^0.4.18;

// 소유자 관리용 계약
contract Owned {
    // 상태 변수
    address public owner; // 소유자 주소

    // 소유자 변경 시 이벤트
    event TransferOwnership(address oldaddr, address newaddr);

    // 소유자 한정 메서드용 수식자
    modifier onlyOwner() { if (msg.sender != owner) revert(); _; }

    // 생성자
    function Owned() public {
        owner = msg.sender; // 처음에 계약을 생성한 주소를 소유자로 한다
    }
    
    // (1) 소유자 변경
    function transferOwnership(address _new) public onlyOwner {
        address oldaddr = owner;
        owner = _new;
        TransferOwnership(oldaddr, owner);
    }
}

// (2) 회원 관리용 계약
contract Members is Owned {
    // (3) 상태 변수 선언
    address public coin; // 토큰(가상 화폐) 주소
    MemberStatus[] public status; // 회원 등급 배열
    mapping(address => History) public tradingHistory; // 회원별 거래 이력
     
    // (4) 회원 등급용 구조체
    struct MemberStatus {
        string name; // 등급명
        uint256 times; // 최저 거래 회수
        uint256 sum; // 최저 거래 금액
        int8 rate; // 캐시백 비율
    }
    // 거래 이력용 구조체
    struct History {
        uint256 times; // 거래 회수
        uint256 sum; // 거래 금액
        uint256 statusIndex; // 등급 인덱스
    }
 
    // (5) 토큰 한정 메서드용 수식자
    modifier onlyCoin() { if (msg.sender == coin) _; }
     
    // (6) 토큰 주소 설정
    function setCoin(address _addr) public onlyOwner {
        coin = _addr;
    }
     
    // (7) 회원 등급 추가
    function pushStatus(string _name, uint256 _times, uint256 _sum, int8 _rate) public onlyOwner {
        status.push(MemberStatus({
            name: _name,
            times: _times,
            sum: _sum,
            rate: _rate
        }));
    }
 
    // (8) 회원 등급 내용 변경
    function editStatus(uint256 _index, string _name, uint256 _times, uint256 _sum, int8 _rate) public onlyOwner {
        if (_index < status.length) {
            status[_index].name = _name;
            status[_index].times = _times;
            status[_index].sum = _sum;
            status[_index].rate = _rate;
        }
    }
     
    // (9) 거래 내역 갱신
    function updateHistory(address _member, uint256 _value) public onlyCoin {
        tradingHistory[_member].times += 1;
        tradingHistory[_member].sum += _value;
        // 새로운 회원 등급 결정(거래마다 실행)
        uint256 index;
        int8 tmprate;
        for (uint i = 0; i < status.length; i++) {
            // 최저 거래 횟수, 최저 거래 금액 충족 시 가장 캐시백 비율이 좋은 등급으로 설정
            if (tradingHistory[_member].times >= status[i].times &&
                tradingHistory[_member].sum >= status[i].sum &&
                tmprate < status[i].rate) {
                index = i;
            }
        }
        tradingHistory[_member].statusIndex = index;
    }

    // (10) 캐시백 비율 획득(회원의 등급에 해당하는 비율 확인)
    function getCashbackRate(address _member) public constant returns (int8 rate) {
        rate = status[tradingHistory[_member].statusIndex].rate;
    }
}
     
// (11) 회원 관리 기능이 구현된 가상 화폐
contract BluewindCoin is Owned {
    // 상태 변수 선언
    string public name; // 토큰 이름
    string public symbol; // 토큰 단위
    uint8 public decimals; // 소수점 이하 자릿수
    uint256 public totalSupply; // 토큰 총량
    mapping (address => uint256) public balanceOf; // 각 주소의 잔고
    mapping (address => int8) public blackList; // 블랙리스트
    mapping (address => Members) public members; // 각 주소의 회원 정보
     
    // 이벤트 알림
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Blacklisted(address indexed target);
    event DeleteFromBlacklist(address indexed target);
    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);
    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);
    event Cashback(address indexed from, address indexed to, uint256 value);
     
    // 생성자
    function BluewindCoin(uint256 _supply, string _name, string _symbol, uint8 _decimals) public {
        balanceOf[msg.sender] = _supply;
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _supply;
    }
 
    // 주소를 블랙리스트에 등록
    function blacklisting(address _addr) public onlyOwner {
        blackList[_addr] = 1;
        Blacklisted(_addr);
    }
 
    // 주소를 블랙리스트에서 해제
    function deleteFromBlacklist(address _addr) public onlyOwner {
        blackList[_addr] = -1;
        DeleteFromBlacklist(_addr);
    }
 
    // 회원 관리 계약 설정
    function setMembers(Members _members) public {
        members[msg.sender] = Members(_members);
    }
 
    // 송금
    function transfer(address _to, uint256 _value) public {
        // 부정 송금 확인
        if (balanceOf[msg.sender] < _value) revert();
        if (balanceOf[_to] + _value < balanceOf[_to]) revert();

        // 블랙리스트에 존재하는 계정은 입출금 불가
        if (blackList[msg.sender] > 0) {
            RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);
        } else if (blackList[_to] > 0) {
            RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);
        } else {
            // (12) 캐시백 금액을 계산(각 대상의 비율을 사용)
            uint256 cashback = 0;
            if(members[_to] > address(0)) {
                cashback = _value / 100 * uint256(members[_to].getCashbackRate(msg.sender));
                members[_to].updateHistory(msg.sender, _value);
            }
 
            balanceOf[msg.sender] -= (_value - cashback);
            balanceOf[_to] += (_value - cashback);
 
            Transfer(msg.sender, _to, _value);
            Cashback(_to, msg.sender, cashback);
        }
    }
}

// (1) 크라우드 세일
contract Crowdsale is Owned {
    // (2) 상태 변수
    uint256 public fundingGoal; // 목표 금액
    uint256 public deadline; // 기한
    uint256 public price; // 토큰 기본 가격
    uint256 public transferableToken; // 전송 가능 토큰
    uint256 public soldToken; // 판매된 토큰
    uint256 public startTime; // 개시 시간
    BluewindCoin public tokenReward; // 지불에 사용할 토큰
    bool public fundingGoalReached; // 목표 도달 플래그
    bool public isOpened; // 크라우드 세일 개시 플래그
    mapping (address => Property) public fundersProperty; // 자금 제공자의 자산 정보
 
    // (3) 자산정보 구조체
    struct Property {
        uint256 paymentEther; // 지불한 Ether
        uint256 reservedToken; // 받은 토큰
        bool withdrawed; // 인출 플래그
    }
 
    // (4) 이벤트 알림
    event CrowdsaleStart(uint fundingGoal, uint deadline, uint transferableToken, address beneficiary);
    event ReservedToken(address backer, uint amount, uint token);
    event CheckGoalReached(address beneficiary, uint fundingGoal, uint amountRaised, bool reached, uint raisedToken);
    event WithdrawalToken(address addr, uint amount, bool result);
    event WithdrawalEther(address addr, uint amount, bool result);
 
    // (5) 수식자
    modifier afterDeadline() { if (now >= deadline) _; }
 
    // (6) 생성자
    function Crowdsale(
        uint _fundingGoalInEthers,
        uint _transferableToken,
        uint _amountOfTokenPerEther,
        BluewindCoin _addressOfTokenUsedAsReward
    ) public {
        fundingGoal = _fundingGoalInEthers * 1 ether;
        price = 1 ether / _amountOfTokenPerEther;
        transferableToken = _transferableToken;
        tokenReward = BluewindCoin(_addressOfTokenUsedAsReward);
    }
 
    // (7) 이름 없는 함수(Ether 받기)
    function () public payable {
        // 개시 전 또는 기간이 지난 경우 예외 처리 
        if (!isOpened || now >= deadline) revert();
 
        // 받은 Ether와 판매 예정 토큰
        uint amount = msg.value;
        uint token = amount / price * (100 + currentSwapRate()) / 100;
        // 판매 예정 토큰의 확인(예정 수를 초과하는 경우는 예외 처리)
        if (token == 0 || soldToken + token > transferableToken) revert();
        // 자산 제공자의 자산 정보 변경
        fundersProperty[msg.sender].paymentEther += amount;
        fundersProperty[msg.sender].reservedToken += token;
        soldToken += token;
        ReservedToken(msg.sender, amount, token);
    }
 
    // (8) 개시(토큰이 예정한 수 이상 있다면 개시)
    function start(uint _durationInMinutes) public onlyOwner {
        if (fundingGoal == 0 || price == 0 || transferableToken == 0 ||
            tokenReward == address(0) || _durationInMinutes == 0 || startTime != 0)
        {
            revert();
        }
        if (tokenReward.balanceOf(this) >= transferableToken) {
            startTime = now;
            deadline = now + _durationInMinutes * 1 minutes;
            isOpened = true;
            CrowdsaleStart(fundingGoal, deadline, transferableToken, owner);
        }
    }
 
    // (9) 교환 비율(개시 시작부터 시간이 적게 경과할수록 더 많은 보상)
    function currentSwapRate() public constant returns(uint) {
        if (startTime + 3 minutes > now) {
            return 100;
        } else if (startTime + 5 minutes > now) {
            return 50;
        } else if (startTime + 10 minutes > now) {
            return 20;
        } else {
            return 0;
        }
    }
 
    // (10) 남은 시간(분 단위)과 목표와의 차이(eth 단위), 토큰 확인용 메서드
    function getRemainingTimeEthToken() public constant returns(uint min, uint shortage, uint remainToken) {
        if (now < deadline) {
            min = (deadline - now) / (1 minutes);
        }
        shortage = (fundingGoal - this.balance) / (1 ether);
        remainToken = transferableToken - soldToken;
    }
 
    // (11) 목표 도달 확인(기한 후 실시 가능)
    function checkGoalReached() public afterDeadline {
        if (isOpened) {
            // 모인 Ether와 목표 Ether 비교
            if (this.balance >= fundingGoal) {
                fundingGoalReached = true;
            }
            isOpened = false;
            CheckGoalReached(owner, fundingGoal, this.balance, fundingGoalReached, soldToken);
        }
    }
 
    // (12) 소유자용 인출 메서드(판매 종료 후 실시 가능)
    function withdrawalOwner() public onlyOwner {
        if (isOpened) revert();

        // 목표 달성: Ether와 남은 토큰. 목표 미달: 토큰
        if (fundingGoalReached) {
        // Ether
            uint amount = this.balance;
            if (amount > 0) {
                bool ok = msg.sender.call.value(amount)();
                WithdrawalEther(msg.sender, amount, ok);
            }
            // 남은 토큰
            uint val = transferableToken - soldToken;
            if (val > 0) {
                tokenReward.transfer(msg.sender, transferableToken - soldToken);
                WithdrawalToken(msg.sender, val, true);
            }
        } else {
            // 토큰
            uint val2 = tokenReward.balanceOf(this);
            tokenReward.transfer(msg.sender, val2);
            WithdrawalToken(msg.sender, val2, true);
        }
    }
 
    // (13) 자금 제공자용 인출 메서드(세일 종료 후 실시 가능)
    function withdrawal() public {
        if (isOpened) return;
        // 이미 인출된 경우 예외 처리
        if (fundersProperty[msg.sender].withdrawed) revert();
        // 목표 달성: 토큰, 목표 미달 : Ether
        if (fundingGoalReached) {
            if (fundersProperty[msg.sender].reservedToken > 0) {
                tokenReward.transfer(msg.sender, fundersProperty[msg.sender].reservedToken);
                fundersProperty[msg.sender].withdrawed = true;
                WithdrawalToken(
                    msg.sender,
                    fundersProperty[msg.sender].reservedToken,
                    fundersProperty[msg.sender].withdrawed
                );
            }
        } else {
            if (fundersProperty[msg.sender].paymentEther > 0) {
                if (msg.sender.call.value(fundersProperty[msg.sender].paymentEther)()) {
                    fundersProperty[msg.sender].withdrawed = true;
                }
                WithdrawalEther(
                    msg.sender,
                    fundersProperty[msg.sender].paymentEther,
                    fundersProperty[msg.sender].withdrawed
                );
            }
        }
    }
} 
```

### How to test

```
1. BluewindCoin
  - Deploy: 10000, "BluewindCoin", "bc", 0
  
2. Clowdsale
  - Deploy: 10, 5000, 100, "BluewindCoin CA" 
  
3. Transfer
  - "Clowdsale CA", 5000
  
4. BalanceOf
  - BluewindCoin CA 계정 -> 5000
  - Clowdsale CA 계정 -> 5000

5. Start
  - 10

6. Fallback
  - 1번 계정 선택, Value 5 ether, (fallback)
  - 2번 계정 선택, Value 5 ether, (fallback)

7. checkGoalReached, fundingGoalReached
  - 10분간 대기
  - 0번 계정 선택
  - checkGoalReached, fundingGoalReached

8. withdrawal
  - 1번 계정선택, withdrawal
  - 2번 계정선택, withdrawal

9. withdrawalOwner
  - 0번 계정에서 withdrawalOwner
```

# 3.1 스마트 계약의 보안

## 보안 패턴

1. Condition-Effects-Interaction 패턴
2. Withdraw 패턴
3. Access Restriction 패턴
4. Mortal 패턴
5. Circuit Breaker 패턴

### Withdraw 패턴

`경매`
```
contract Auction {
    
    address public highhestBidder;
    
    uint public highhestBid;

    function Auction() public payable {
        highhestBidder = msg.sender;
        highhestBid = 0;
    }
    
    // 입찰 처리 함수
    function bid() public payable {
        require(msg.value > highhestBid);
        
        uint refundAmount = highhestBid;
        
        address currentHighhestBidder = highhestBidder;
        
        highhestBid = msg.value;
        highhestBidder = msg.sender;
        
        // 이전 최고액 입찰자에게 입찰금 반환
        if (!currentHighhestBidder.send(refundAmount)) {
            revert();    
        }
    }
}
```

`악의적인 계약`
```
contract EvilBidder {
    
    function() public payable {
        revert();
    }
    
    function bid(address _to) public payable {
        if (!_to.call.value(msg.value)(bytes4(sha3("bid()")))) {
            throw;
        }
    }
}
```

```
> var au = eth.contract([]).at('0x9c98e7dd51bfdca025e2ce488696e0a87ceb4c6b')
> var db = eth.contract([]).at('0xb434963fbc8cfed2d622f8d05a792fa612d51f06')
> au.highhestBid()
0
> au.highhestBidder()
"0xbfa12bc27bd8a01a77543a6094b8882f85a2dd58"
> web3.fromWei(eth.getBalance(eth.accounts[1]), "ether")
200.989432884
> web3.fromWei(eth.getBalance(eth.accounts[2]), "ether")
295.985790836
> web3.fromWei(eth.getBalance(eth.accounts[3]), "ether")
199.995910112
> personal.unlockAccount(eth.accounts[1])
Unlock account 0x7e0fc0342326a8645e1913771d42917c3a65c119
Passphrase: 
true
> au.bid.sendTransaction({from:eth.accounts[1], gas:500000, value:web3.toWei(1,"ether")})
"0x4875bde8824982f618d7daa5e4d5e29516785acb752c35064c36133670515601"
> web3.fromWei(au.highhestBid(), "ether")
> db.bid.sendTransaction(au.address, {from:eth.accounts[1], gas:50000, value:web3.toWei(5, "ether)})
```

### Access Restriction 패턴

* 접근 제한 여부와 상관없이 public으로 두는 함수를 최소화
* 특정 어드레스만 호출해야 하는 함수는 반드시 해당 어드레스만 접근할 수 있도록 함 
* 접근 제한은 modifier를 구현하여 적용
* 소유자를 변경하는 함수도 필요
* 추상화하여 상속하는 방식으로 사용

```
pragma solidity ^0.4.18;

contract Owned {
    
    address public owner;
    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    
    function owned() internal {
        owner = msg.sender;
    }
    
    function changeOwner(address _newOwner) public onlyOwner {
        owner = _newOwner;
    }
}

contract AccessRestrictionDemo is Owned {
    
    string public somestate;
    
    function AccessRestrictionDemo() public {
        owned();
        somestate = "initial";
    }
    
    function updateSomeState(string _newState) public onlyOwner {
        somestate = _newState;
    }
}
```

### Mortal 패턴

더 이상 필요하지 않게 된 계약을 그때그때 소멸시키는 패턴

```
contract Mortal is Owned {
    
    //계약을 소멸시키고 보유한 이더를 소유자에게 송금
    function kill() public onlyOwner {
        selfdestruct(owner);
    }
}

contract MortalSample is Mortal {
    
    string public somestate;
    
    function() public payable {
    }
    
    function MortalSample() public {
        owned();
        somestate = "initial";
    }
}
```

### Circuit Breaker 패턴

한번 생성된 스마트 계약은 수정할 수 없으므로 버그나 취약점이 발견되면 오동작이나 공격받을 가능성이 존재

문제가 발생했을 시에는 일단 임시로라도 기능을 정지

계약에 긴급 정지 장치를 추가

```
contract CircuitBreakerDemo {
    
    bool public stopped;
    address public owner;
    bytes16 public message;
    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    
    modifier isStopped() {
        require(!stopped);
        _;
    }
    
    function CircuitBreakerDemo() public {
        owner = msg.sender;
        stopped = false;
    }
    
    function toggleCircuit(bool _stopped) public onlyOwner {
        stopped = _stopped;
    }
    
    function message(bytes16 _message) public isStopped {
        message = _message;
    }
}
```

```
> var cb = eth.contract(abi).at('cb-address')
> cb.stopped()
false
> cb.setMessage.sendTransaction("aaa", {from:eth.accounts[0], gas:500000})
"0x045569ec1f489e3d309b5a92556624e6e3694aa586e983268a6fb9c47ee34117"
> web3.toUtf8(cb.message())
"aaa"

> cb.toggleCircuit.sendTransaction(true, {from:eth.accounts[0], gas:500000})
"0xdc67f05731cbea80fc7b4f27cbe5f20b53d4098335b58258bbe56444875971aa"
> cb.setMessage.sendTransaction("ccc", {from:eth.accounts[0], gas:500000})
"0xce09f57acc6739c4520ab68b2167cd22d647edbf01a9d0450efda92ca27d12bf"
> web3.toUtf8(cb.message())
"bbb"
```

## 취약점(Vulnerability)

1. 재진입성(Reentrancy) 문제
2. TOD(Transaction-Ordering Depndence)
3. Timestamp Dependence
4. 중요 정보 취급
5. 오버플로


# 4. 기타사항
## ICO(Initial Coin Offering)

* 블록체인 비즈니스
* 토큰 이코노미
* 플랫폼/글로벌 비즈니스
* <span style="background-color:blue;color:white">투명성</span>
  - 백서(Whitepaper)
  - 스마트 컨트랙트(Smart Contract)
  - 토큰 매트릭스(Token Matrix)
  - 참여자: Founders, Advisors, Development Team

## 블록체인 백서(Whitepaper)

>비즈니스 모델에 대한 보고서

* 무엇을 개선하려고 하는가?
* 왜 블록체인인가?
* 왜 코인이 필요한가?
* 진정한 탈중앙화(Decentralized)인가?

## 블록체인의 문제점 및 해결책?

- 트릴레마
  + 탈중앙화, 확장성, 합의

- 탈중앙화의 왜곡
  + 채굴공장, 거래소

- 속도: 초당 7건

- 합의

- 개인정보

- 성숙도

# 참조

* [Ethereum Wallet and Mist](https://github.com/ethereum/mist/releases)

* [Remix](https://remix.ethereum.org)

* [Ethereum IDE and tools for the web](https://github.com/ethereum/remix)

* [Gas](http://gas.eth.guide/)

* [ETH Gas Station](https://ethgasstation.info/)

* [솔리디티 릴리즈 노트](https://github.com/ethereum/solidity/releases)

* [Embark](https://github.com/embark-framework/embark)

* [Web3](https://github.com/ethereum/web3.js/)

* [Ethereum](https://github.com/ethereum)

* [Web3 Readdoc](https://web3js.readthedocs.io/en/1.0/)

* [CodingGround](https://www.tutorialspoint.com/codingground.htm)

* [web3j](https://web3j.readthedocs.io/en/latest/)

* [Common Patterns](http://solidity.readthedocs.io/en/v0.4.24/common-patterns.html)

* [한국블록체인비즈니스 연구회 케블리](https://steemit.com/@kblock)